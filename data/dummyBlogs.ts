import { Blog } from "@/types";
export const dummyBlogs: Blog[] = [
  {
    id: 1,
    title: "The Rise of JavaScript Frameworks in 2025",
    description:
      '<p>JavaScript has always been at the heart of modern web development, but 2025 has marked a pivotal point in how developers build applications. With innovation booming and developer experience becoming a top priority, JavaScript frameworks have taken a massive leap forward â€” not just in popularity but in capability.</p><p><br></p><h2><strong>The Evolution of Frameworks</strong></h2><p>In the early 2010s, developers leaned heavily on libraries like jQuery to simplify DOM manipulation. Then came the era of component-based frameworks â€” React, Vue, and Angular. These changed the game by introducing more maintainable, scalable architectures.</p><p>But in 2025, weâ€™re seeing a new wave: frameworks are no longer just about components â€” theyâ€™re about <strong>performance, flexibility, and full-stack integration</strong>.</p><p><br></p><h2><strong>Top Trends in 2025</strong></h2><h3>1. <strong>Meta-Frameworks Are Taking Ove</strong>r</h3><p>Frameworks like <strong>Next.js</strong>, <strong>Nuxt 4</strong>, and <strong>SvelteKit</strong> are no longer just optional tools â€” they are the new default. They combine frontend rendering with powerful backend capabilities, enabling full-stack development within a single framework.</p><p><br></p><h3>2. <strong>Island Architecture Gains Momentum</strong></h3><p>Thanks to the push for faster loading speeds and better Core Web Vitals, frameworks embracing <em>partial hydration</em> like <strong>Astro</strong> and <strong>Qwik</strong> are gaining serious traction. These frameworks send less JavaScript to the client while preserving interactivity.</p><p><br></p><h3>3. <strong>Type Safety Everywhere</strong></h3><p>Frameworks with strong TypeScript support have become industry standard. <strong>SolidStart</strong> and <strong>Remix 2.0</strong> now offer out-of-the-box type safety, server-first architecture, and great developer tooling.</p><p><br></p><h2><strong>Developer Experience Matters More Than Ever</strong></h2><p>In 2025, developers expect tools that "just work" â€” fast refresh, built-in routing, great error messages, and minimal boilerplate. Frameworks that provide better DX (Developer Experience) are being adopted rapidly, even by large enterprises.</p><p><br></p><h2>What This Means for Developers</h2><p>If you\'re a frontend developer in 2025, understanding just JavaScript isn\'t enough. You need to be familiar with:</p><ol><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Rendering strategies (SSR, ISR, CSR, etc.)</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Hybrid frameworks and meta-frameworks</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Build tools like Vite and Turbopack</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>API routes and backend integration</li></ol>',
    image: "/images/image1.png",
    createdAt: "2025-04-10T06:53:51.386Z",
  },
  {
    id: 2,
    title: "Top 5 VS Code Extensions for Developers",
    description:
      '<p>Visual Studio Code (VS Code) is one of the most loved code editors among developers â€” and for good reason. It\'s lightweight, fast, highly customizable, and most importantly, has a rich ecosystem of extensions that can dramatically improve your productivity and workflow.</p><p><br></p><p>In this blog, weâ€™ll explore <strong>five must-have VS Code extensions</strong> that every developer should consider using in 2025.</p><p><br></p><h2>1. <strong>ESLint</strong></h2><p>If youâ€™re working with JavaScript or TypeScript, <strong>ESLint</strong> is a must-have.</p><p>It automatically checks your code for syntax errors and enforces coding standards. With real-time feedback and autofix features, you can catch bugs early and write cleaner, more consistent code.</p><blockquote>ðŸ’¡ Pro Tip: Pair it with Prettier for automatic formatting on save.</blockquote><p><br></p><h2>2. <strong>Prettier â€“ Code Formatter</strong></h2><p>Clean code is easier to read and maintain. <strong>Prettier</strong> formats your code automatically based on pre-defined rules â€” no more arguing about spaces vs. tabs or trailing commas.</p><p>Just hit save, and Prettier will do its magic.</p><p><br></p><h2>3. <strong>GitLens</strong></h2><p>Want to know who last edited a line of code and why? <strong>GitLens</strong> supercharges your Git integration inside VS Code.</p><p>With powerful features like blame annotations, commit history, and line history, GitLens helps you understand your codebase better and track down bugs faster.</p><p><br></p><h2>4. <strong>Path Intellisense</strong></h2><p>Tired of manually typing out long file paths? <strong>Path Intellisense</strong> auto-completes filenames as you type.</p><p>Itâ€™s a small extension, but it saves a ton of time when importing files or working with assets in larger projects.</p><p><br></p><h2>5. <strong>Tailwind CSS IntelliSense</strong></h2><p>For frontend developers using Tailwind CSS, this extension is a game changer.</p><p><strong>Tailwind CSS IntelliSense</strong> provides autocomplete, hover previews, and linting for Tailwind utility classes â€” making your development faster and more intuitive.</p><p><br></p><h2><strong>Bonus Picks</strong></h2><p>Here are a few honorable mentions:</p><ol><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Live Server</strong>: Instantly preview your HTML and CSS projects in the browser.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Bracket Pair Colorizer 2</strong>: Color-codes matching brackets for better readability.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Thunder Client</strong>: Lightweight alternative to Postman for testing APIs directly inside VS Code.</li></ol>',
    image: "/images/image2.png",
    createdAt: "2025-04-11T14:21:37.147Z",
  },
  {
    id: 3,
    title: "Understanding useEffect in React: A Beginner's Guide",
    description:
      '<p>React makes building user interfaces smooth and efficient, but when it comes to running side effects â€” like fetching data, setting up subscriptions, or working with the browser API â€” youâ€™ll need a special tool. Thatâ€™s where the useEffect hook comes in.</p><p><br></p><p>In this blog, we\'ll walk through what useEffect is and how to use it, especially if you\'re new to React.</p><p><br></p><h2><strong>What is useEffect?</strong></h2><p>useEffect is a hook provided by React that lets you run side effects in your functional components. These side effects might include:</p><ol><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Fetching data from an API</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Changing the document title</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Listening for events (like scrolling or resizing)</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Working with localStorage or browser APIs</li></ol><p><br></p><p>Before hooks, you had to use class components and lifecycle methods like componentDidMount and componentDidUpdate. Now, with hooks, functional components can handle these tasks easily using useEffect.</p><p><br></p><h2><strong>How useEffect Works</strong></h2><p>You give useEffect a function to run after the component renders. You can also pass a second argument: an array of dependencies. This tells React when to re-run the effect.</p><p>If you pass an empty array as the second argument, the effect runs only once when the component first appears. This is similar to the behavior of componentDidMount.</p><p>If you include a value (like a state variable) in the array, the effect will run every time that value changes.</p><p><br></p><h2><strong>Example Use Cases</strong></h2><ol><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>You might use useEffect to fetch blog posts when the blog page loads.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>You can update the document title when a user logs in.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>You might listen for window resizing and clean up the listener when the component unmounts.</li></ol><p><br></p><h2><strong>Cleanup with useEffect</strong></h2><p>Sometimes, your effect needs to clean up after itself. For example, if you start a timer or attach an event listener, you should stop it when the component is removed. To do that, your useEffect function can return another function â€” React will run this returned function when the component unmounts or before re-running the effect.</p><p><br></p><h2><strong>Common Mistakes to Avoid</strong></h2><ol><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Forgetting the dependency array: this causes the effect to run on every render.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Not including all necessary dependencies: this may cause bugs or stale data.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Updating state without control: updating state inside an effect without proper conditions can cause an infinite loop.</li></ol>',
    image: "/images/image3.png",
    createdAt: "2025-04-12T07:52:23.024Z",
  },
  {
    id: 4,
    title: "What is localStorage and How Does It Work?",
    description:
      '<p>In modern web development, it\'s often necessary to store data in the browser â€” whether that\'s user preferences, form data, or something like authentication flags. One of the easiest ways to do this is by using <strong>localStorage</strong>.</p><p><br></p><p>In this blog, weâ€™ll explore what localStorage is, how it works, and when (or when not) to use it.</p><p><br></p><h2><strong>What is localStorage?</strong></h2><p>localStorage is a feature built into modern web browsers that allows websites to store key-value pairs in the browser â€” <strong>persistently</strong>. This means the data stays in place even after the user closes the browser or refreshes the page.</p><p><br></p><p>It is part of the Web Storage API, along with sessionStorage, and is commonly used for storing small amounts of data that need to be accessed across sessions.</p><p><br></p><h2><strong>Key Features</strong></h2><ol><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>The data is stored in string format.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>It persists even after the browser is closed or the device is restarted.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>It has a limit (usually about 5MB per domain).</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>It\'s synchronous, which means it doesnâ€™t run in the background.</li></ol><p><br></p><h2><strong>When to Use localStorage</strong></h2><p>localStorage is perfect for:</p><ol><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Saving user preferences like dark mode</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Storing login states (with caution)</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Saving form data temporarily</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Caching non-sensitive information</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Managing simple app state for small projects</li></ol><p><br></p><h2><strong>When NOT to Use localStorage</strong></h2><p>Despite being convenient, localStorage has some limitations. Itâ€™s not ideal for:</p><ol><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Storing sensitive information like passwords or tokens</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Handling large amounts of data</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Apps that require high security</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Collaborative apps where real-time sync is needed</li></ol><p><br></p><p>If your data is private or sensitive, use secure server-side storage or more robust solutions like encrypted cookies or session-based authentication.</p><p><br></p><h2><strong>How Does It Work?</strong></h2><p>localStorage works by allowing you to save and retrieve data using a key. You set a key with a value and retrieve it later using the same key. Everything stored must be converted to a string. If you\'re working with arrays or objects, you need to convert them using a method like JSON serialization.</p><p><br></p><p>The stored data is specific to a domain, meaning other websites cannot access your appâ€™s data, keeping things scoped and safe within your project.</p>',
    image: "/images/image4.png",
    createdAt: "2025-04-12T08:07:32.783Z",
  },
  {
    id: 5,
    title: "Tailwind CSS vs Traditional CSS: Pros and Cons",
    description:
      '<p>As the web continues to evolve, so do the tools and approaches we use to style websites. One of the biggest debates in recent years has been between using <strong>Tailwind CSS</strong>, a utility-first CSS framework, and <strong>Traditional CSS</strong>, which includes plain CSS or preprocessor-based styles like SCSS. Each has its own philosophy, strengths, and weaknesses.</p><p><br></p><p>In this blog, weâ€™ll explore both approaches and help you decide which one might be right for your project.</p><p><br></p><h2><strong>What is Tailwind CSS?</strong></h2><p>Tailwind CSS is a utility-first CSS framework that provides low-level utility classes directly in your HTML to style elements. Instead of writing custom class names and styles in a separate file, you compose your UI using pre-defined classes like padding, margin, color, and layout helpers.</p><p>Itâ€™s designed to speed up development and maintain consistency across a project.</p><p><br></p><h2><strong>What is Traditional CSS?</strong></h2><p>Traditional CSS refers to writing styles in a .css file (or .scss, .less, etc.) using class or ID selectors. This is how most developers have styled websites for decades. You define reusable class names and apply them in your HTML to apply consistent styles.</p><p>This method separates structure (HTML) from styling (CSS), following the common principle of separation of concerns.</p><p><br></p><h2><strong>Pros of Tailwind CSS</strong></h2><ol><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Rapid Development:</strong> You can quickly build UIs by combining utility classes without switching between HTML and CSS files.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Consistency:</strong> Design decisions are often baked into the utility classes, which helps maintain a consistent look and feel.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Customization:</strong> You can configure your design system (colors, spacing, fonts) in the Tailwind config.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Less CSS Bloat:</strong> With proper configuration (like purging unused classes), Tailwind can result in smaller final CSS files.</li></ol><p><br></p><h2><strong>Cons of Tailwind CSS</strong></h2><ol><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Readability Issues:</strong> HTML can become cluttered with long class lists, making it harder to read for some developers.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Learning Curve:</strong> Understanding and memorizing utility class names takes time, especially for beginners.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Inline-Style Vibe:</strong> Critics say it feels like writing inline styles, which some consider bad practice.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Harder to Override:</strong> Overriding styles might feel tricky if you\'re deeply nested in utility classes.</li></ol><p><br></p><h2><strong>Pros of Traditional CSS</strong></h2><ol><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Clear Separation:</strong> Your HTML stays clean while all styling is done in dedicated CSS files.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Familiarity:</strong> Most developers are taught CSS first, and the syntax is widely understood.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Powerful Selectors:</strong> You can style based on element states, nesting, and other complex structures with ease.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Easier for Designers:</strong> Traditional CSS often aligns better with design handoffs or design system documentation.</li></ol><p><br></p><h2><strong>Cons of Traditional CSS</strong></h2><ol><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Global Scope Issues:</strong> Without proper structuring, styles can leak and affect unintended elements.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Harder Maintenance:</strong> As projects grow, CSS files can become hard to manage and debug.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Slower Development:</strong> Constantly switching between files and writing custom styles slows down iteration.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span><strong>Naming Conflicts:</strong> Choosing meaningful and unique class names can be challenging.</li></ol><p><br></p><h2><strong>Which One Should You Use?</strong></h2><ol><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Choose <strong>Tailwind CSS</strong> if you want rapid development, a consistent design system, and are comfortable with utility-first syntax.</li><li data-list="ordered"><span class="ql-ui" contenteditable="false"></span>Stick with <strong>Traditional CSS</strong> if your team values clean HTML, follows BEM or similar naming conventions, or prefers design separation.</li></ol>',
    image: "/images/image5.jpeg",
    createdAt: "2025-04-12T09:34:49.721Z",
  },
];
